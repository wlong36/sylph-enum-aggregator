<#-- templates/default_enum_registrar.ftl -->
<#-- This template expects a data model with:
    - packageName (String): Package for the generated registrar class
    - className (String): Simple name for the generated registrar class (e.g., "SylphEnumRegistrarImpl")
    - interfaceName (String): Simple name of the interface being implemented (e.g., "SylphEnumRegistrar")
    - interfacePackage (String): Package of the interface being implemented
    - enums (List<Map<String, Object>>) where each map has:
        - name (String): The simple name of the enum class to register (e.g., "ConditionType")
-->
package ${packageName};

import javax.annotation.processing.Generated; // Optional: Add @Generated annotation
import ${enumInterfaceClass};
import ${registrarInterfaceClass};
import ${registrationContextClass};
import javax.annotation.Nonnull; // Use Nonnull if specified in interface

// Import the actual enum types generated by protobuf plugin
// Assuming they will be in the same package as the registrar or proto package
// If proto package differs significantly, this might need adjustment or fully qualified names.
// We'll assume the user's build setup makes them available.
// Alternatively, use fully qualified names in registrationContext.registerEnum() call.
<#-- Note: This import section is tricky without knowing the final proto Java package.
     Let's assume the fully qualified name is used in the registerEnum call for robustness.
     If `protoPackage` is reliably the same as `registrarPackage`, you could add imports:
<#list enums as enum>
import ${protoPackage}.${enum.name};
</#list>
-->


/**
* Generated by sylph-enum-aggregator. DO NOT EDIT.
* Implements the service provider interface to register aggregated enums.
*/
@Generated("io.github.wlong36.sylph.enumaggregator.processor.SylphEnumProcessor") // Optional marker
public final class ${className} implements ${registrarInterfaceName} {

    @Override
    public void doRegister(@Nonnull SylphEnumRegistrationContext registrationContext) {
    // Register each discovered enum type using its fully qualified name
    <#-- Construct the fully qualified name assuming the enums are generated
         into the package defined by the OPTION_PROTO_PACKAGE (this.protoPackage in Java).
         If proto generation uses a different Java package option, this needs refinement.
     -->
    <#list enums as enum>
        try {
            // Construct the expected fully qualified name based on proto package and enum name
            String enumClassName = "${protoPackage}.${enum.name}"; // Example: io.github.wlong36...generated.ConditionType
            @SuppressWarnings("unchecked") // Suppress warning for cast to Class<? extends Enum>
            Class<? extends SylphEnum> enumClass = (Class<? extends SylphEnum>) Class.forName(enumClassName);
<#--            registrationContext.register(enumClass);-->
        } catch (ClassNotFoundException e) {
            // Log or handle error - the enum class expected wasn't found.
            // This might indicate a build configuration issue or mismatch
            // between proto generation options and processor assumptions.
            System.err.println("SylphEnumRegistrar Error: Failed to find generated enum class: " + "${protoPackage}.${enum.name}" + ". Registration skipped. Check build configuration.");
            // Optionally rethrow as a runtime exception?
            // throw new RuntimeException("Failed to find generated enum class: " + "${protoPackage}.${enum.name}", e);
            } catch (ClassCastException e) {
            // Should not happen if it's an enum, but good to catch.
            System.err.println("SylphEnumRegistrar Error: Class " + "${protoPackage}.${enum.name}" + " is not an Enum. Registration skipped.");
        }
    </#list>
    }
}